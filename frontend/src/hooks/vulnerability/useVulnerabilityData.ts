import { useState, useEffect, useMemo } from "react";
import {
  Vulnerability,
  VulnerabilitySummary,
  VulnerabilityTrend,
} from "../../types/vulnerability.types";
import mockVulnerabilities from "../../data/mockVulnerabilities";

interface UseVulnerabilityDataProps {
  initialData?: Vulnerability[];
  fetchFromApi?: boolean;
}

interface UseVulnerabilityDataReturn {
  vulnerabilities: Vulnerability[];
  filteredVulnerabilities: Vulnerability[];
  isLoading: boolean;
  error: Error | null;
  summary: VulnerabilitySummary;
  searchTerm: string;
  setSearchTerm: (term: string) => void;
  severityFilter: string;
  setSeverityFilter: (severity: string) => void;
  statusFilter: string;
  setStatusFilter: (status: string) => void;
  startDate: Date | null;
  setStartDate: (date: Date | null) => void;
  endDate: Date | null;
  setEndDate: (date: Date | null) => void;
  sortField: string;
  setSortField: (field: string) => void;
  sortDirection: "asc" | "desc";
  setSortDirection: (direction: "asc" | "desc") => void;
  updateVulnerabilityStatus: (id: string, status: string) => void;
  resetFilters: () => void;
  refreshData: () => void;
  isRefreshing: boolean;
  trends: VulnerabilityTrend[];
}

export function useVulnerabilityData({
  initialData,
  fetchFromApi = false,
}: UseVulnerabilityDataProps = {}): UseVulnerabilityDataReturn {
  const [vulnerabilities, setVulnerabilities] = useState<Vulnerability[]>(
    initialData || []
  );
  const [filteredVulnerabilities, setFilteredVulnerabilities] = useState<
    Vulnerability[]
  >([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const [trends, setTrends] = useState<VulnerabilityTrend[]>([]);

  // Filter states
  const [searchTerm, setSearchTerm] = useState("");
  const [severityFilter, setSeverityFilter] = useState("All");
  const [statusFilter, setStatusFilter] = useState("All");
  const [startDate, setStartDate] = useState<Date | null>(null);
  const [endDate, setEndDate] = useState<Date | null>(null);
  const [sortField, setSortField] = useState("severityLevel");
  const [sortDirection, setSortDirection] = useState<"asc" | "desc">("desc");

  // Generate mock trend data
  const generateTrendData = () => {
    const today = new Date();
    const data: VulnerabilityTrend[] = [];

    // Generate data for the last 7 days
    for (let i = 6; i >= 0; i--) {
      const date = new Date();
      date.setDate(today.getDate() - i);

      data.push({
        date: new Date(date),
        critical:
          Math.floor(Math.random() * 5) +
          (i === 0
            ? vulnerabilities.filter((v) => v.severityLevel === "Critical")
                .length
            : 0),
        high:
          Math.floor(Math.random() * 8) +
          (i === 0
            ? vulnerabilities.filter((v) => v.severityLevel === "High").length
            : 0),
        medium:
          Math.floor(Math.random() * 10) +
          (i === 0
            ? vulnerabilities.filter((v) => v.severityLevel === "Medium").length
            : 0),
        low:
          Math.floor(Math.random() * 12) +
          (i === 0
            ? vulnerabilities.filter((v) => v.severityLevel === "Low").length
            : 0),
      });
    }

    return data;
  };

  // Fetch vulnerabilities from API or use mock data
  useEffect(() => {
    const fetchData = async () => {
      setIsLoading(true);
      try {
        if (fetchFromApi) {
          // In a real app, you would fetch from an API
          // For demo, simulate API call with timeout
          await new Promise((resolve) => setTimeout(resolve, 1000));
        }

        // Use mock data or initialData if provided
        const data = initialData || mockVulnerabilities;
        setVulnerabilities(data);
        setFilteredVulnerabilities(data);

        // Generate trend data
        setTrends(generateTrendData());
      } catch (err) {
        setError(
          err instanceof Error ? err : new Error("Unknown error occurred")
        );
      } finally {
        setIsLoading(false);
      }
    };

    fetchData();
  }, [fetchFromApi, initialData]);

  // Apply filters and sorting
  useEffect(() => {
    let result = [...vulnerabilities];

    // Apply search filter
    if (searchTerm) {
      result = result.filter(
        (vuln) =>
          vuln.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
          vuln.type.toLowerCase().includes(searchTerm.toLowerCase()) ||
          vuln.affectedAssets.some((asset) =>
            asset.toLowerCase().includes(searchTerm.toLowerCase())
          )
      );
    }

    // Apply severity filter
    if (severityFilter !== "All") {
      result = result.filter((vuln) => vuln.severityLevel === severityFilter);
    }

    // Apply status filter
    if (statusFilter !== "All") {
      result = result.filter((vuln) => vuln.status === statusFilter);
    }

    // Apply date range filter
    if (startDate) {
      result = result.filter(
        (vuln) => new Date(vuln.discoveryDate) >= startDate
      );
    }

    if (endDate) {
      const endOfDay = new Date(endDate);
      endOfDay.setHours(23, 59, 59, 999);
      result = result.filter(
        (vuln) => new Date(vuln.discoveryDate) <= endOfDay
      );
    }

    // Apply sorting
    result.sort((a, b) => {
      if (sortField === "cvssScore") {
        return sortDirection === "asc"
          ? a.cvssScore - b.cvssScore
          : b.cvssScore - a.cvssScore;
      } else if (sortField === "discoveryDate") {
        return sortDirection === "asc"
          ? new Date(a.discoveryDate).getTime() -
              new Date(b.discoveryDate).getTime()
          : new Date(b.discoveryDate).getTime() -
              new Date(a.discoveryDate).getTime();
      } else if (sortField === "severityLevel") {
        const severityOrder: Record<string, number> = {
          Critical: 4,
          High: 3,
          Medium: 2,
          Low: 1,
        };
        return sortDirection === "asc"
          ? severityOrder[a.severityLevel] - severityOrder[b.severityLevel]
          : severityOrder[b.severityLevel] - severityOrder[a.severityLevel];
      }
      return 0;
    });

    setFilteredVulnerabilities(result);
  }, [
    vulnerabilities,
    searchTerm,
    severityFilter,
    statusFilter,
    startDate,
    endDate,
    sortField,
    sortDirection,
  ]);

  // Calculate summary statistics
  const summary = useMemo(() => {
    const criticalCount = vulnerabilities.filter(
      (v) => v.severityLevel === "Critical"
    ).length;
    const highCount = vulnerabilities.filter(
      (v) => v.severityLevel === "High"
    ).length;
    const mediumCount = vulnerabilities.filter(
      (v) => v.severityLevel === "Medium"
    ).length;
    const lowCount = vulnerabilities.filter(
      (v) => v.severityLevel === "Low"
    ).length;
    const fixedCount = vulnerabilities.filter(
      (v) => v.status === "Fixed"
    ).length;
    const notFixedCount = vulnerabilities.filter(
      (v) => v.status === "Not Fixed"
    ).length;
    const inProgressCount = vulnerabilities.filter(
      (v) => v.status === "In Progress"
    ).length;

    // Find most affected asset
    const assetCounts = vulnerabilities.reduce(
      (acc: Record<string, number>, vuln) => {
        vuln.affectedAssets.forEach((asset) => {
          acc[asset] = (acc[asset] || 0) + 1;
        });
        return acc;
      },
      {}
    );

    const mostAffectedAsset = Object.entries(assetCounts).reduce(
      (max, [asset, count]) =>
        count > max.count ? { name: asset, count } : max,
      { name: "", count: 0 }
    );

    return {
      total: vulnerabilities.length,
      critical: criticalCount,
      high: highCount,
      medium: mediumCount,
      low: lowCount,
      fixed: fixedCount,
      notFixed: notFixedCount,
      inProgress: inProgressCount,
      mostAffectedAsset,
    };
  }, [vulnerabilities]);

  // Update vulnerability status
  const updateVulnerabilityStatus = (id: string, status: string) => {
    const updatedVulnerabilities = vulnerabilities.map((vuln) =>
      vuln.id === id
        ? { ...vuln, status: status as "Fixed" | "Not Fixed" | "In Progress" }
        : vuln
    );
    setVulnerabilities(updatedVulnerabilities);
  };

  // Reset filters
  const resetFilters = () => {
    setSearchTerm("");
    setSeverityFilter("All");
    setStatusFilter("All");
    setStartDate(null);
    setEndDate(null);
    setSortField("severityLevel");
    setSortDirection("desc");
  };

  const refreshData = async () => {
    setIsRefreshing(true);
    try {
      // In a real app, you would fetch from an API
      // For demo, simulate API call with timeout
      await new Promise((resolve) => setTimeout(resolve, 1500));

      // Simulate getting new data by slightly modifying the existing data
      const updatedVulnerabilities = mockVulnerabilities.map((vuln) => {
        // Randomly update some statuses
        if (Math.random() > 0.7) {
          const statuses: ("Fixed" | "Not Fixed" | "In Progress")[] = [
            "Fixed",
            "Not Fixed",
            "In Progress",
          ];
          const randomStatus =
            statuses[Math.floor(Math.random() * statuses.length)];
          return { ...vuln, status: randomStatus, lastUpdated: new Date() };
        }
        return vuln;
      });

      // Add a new vulnerability occasionally
      if (Math.random() > 0.5) {
        const newVuln: Vulnerability = {
          id: `new-${Date.now()}`,
          name: `CVE-2024-${Math.floor(1000 + Math.random() * 9000)}`,
          type: [
            "SQL Injection",
            "XSS",
            "CSRF",
            "Path Traversal",
            "Authentication Bypass",
          ][Math.floor(Math.random() * 5)],
          cvssScore: Math.floor(Math.random() * 10 * 10) / 10,
          severityLevel: ["Critical", "High", "Medium", "Low"][
            Math.floor(Math.random() * 4)
          ] as "Critical" | "High" | "Medium" | "Low",
          affectedAssets: [
            "Web Application",
            "Database Server",
            "API Gateway",
          ].slice(0, Math.floor(Math.random() * 3) + 1),
          discoveryDate: new Date(),
          status: "Not Fixed",
          description:
            "Newly discovered vulnerability that requires investigation.",
          recommendations:
            "Currently under investigation. Recommendations pending.",
          cveReferences: [
            `CVE-2024-${Math.floor(1000 + Math.random() * 9000)}`,
          ],
          lastUpdated: new Date(),
        };
        updatedVulnerabilities.push(newVuln);
      }

      setVulnerabilities(updatedVulnerabilities);
      setTrends(generateTrendData());
    } catch (err) {
      setError(
        err instanceof Error ? err : new Error("Failed to refresh data")
      );
    } finally {
      setIsRefreshing(false);
    }
  };

  return {
    vulnerabilities,
    filteredVulnerabilities,
    isLoading,
    error,
    summary,
    searchTerm,
    setSearchTerm,
    severityFilter,
    setSeverityFilter,
    statusFilter,
    setStatusFilter,
    startDate,
    setStartDate,
    endDate,
    setEndDate,
    sortField,
    setSortField,
    sortDirection,
    setSortDirection,
    updateVulnerabilityStatus,
    resetFilters,
    refreshData,
    isRefreshing,
    trends,
  };
}
