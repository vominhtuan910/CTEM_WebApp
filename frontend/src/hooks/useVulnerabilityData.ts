import { useState, useEffect, useMemo } from 'react';
import { Vulnerability, VulnerabilitySummary } from '../types/vulnerability.types';
import mockVulnerabilities from '../data/mockVulnerabilities';

interface UseVulnerabilityDataProps {
  initialData?: Vulnerability[];
  fetchFromApi?: boolean;
}

interface UseVulnerabilityDataReturn {
  vulnerabilities: Vulnerability[];
  filteredVulnerabilities: Vulnerability[];
  isLoading: boolean;
  error: Error | null;
  summary: VulnerabilitySummary;
  searchTerm: string;
  setSearchTerm: (term: string) => void;
  severityFilter: string;
  setSeverityFilter: (severity: string) => void;
  statusFilter: string;
  setStatusFilter: (status: string) => void;
  startDate: Date | null;
  setStartDate: (date: Date | null) => void;
  endDate: Date | null;
  setEndDate: (date: Date | null) => void;
  sortField: string;
  setSortField: (field: string) => void;
  sortDirection: 'asc' | 'desc';
  setSortDirection: (direction: 'asc' | 'desc') => void;
  updateVulnerabilityStatus: (id: string, status: string) => void;
  resetFilters: () => void;
}

export function useVulnerabilityData({
  initialData,
  fetchFromApi = false,
}: UseVulnerabilityDataProps = {}): UseVulnerabilityDataReturn {
  const [vulnerabilities, setVulnerabilities] = useState<Vulnerability[]>(initialData || []);
  const [filteredVulnerabilities, setFilteredVulnerabilities] = useState<Vulnerability[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  
  // Filter states
  const [searchTerm, setSearchTerm] = useState('');
  const [severityFilter, setSeverityFilter] = useState('All');
  const [statusFilter, setStatusFilter] = useState('All');
  const [startDate, setStartDate] = useState<Date | null>(null);
  const [endDate, setEndDate] = useState<Date | null>(null);
  const [sortField, setSortField] = useState('severityLevel');
  const [sortDirection, setSortDirection] = useState<'asc' | 'desc'>('desc');

  // Fetch vulnerabilities from API or use mock data
  useEffect(() => {
    const fetchData = async () => {
      setIsLoading(true);
      try {
        if (fetchFromApi) {
          // In a real app, you would fetch from an API
          // For demo, simulate API call with timeout
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
        
        // Use mock data or initialData if provided
        const data = initialData || mockVulnerabilities;
        setVulnerabilities(data);
        setFilteredVulnerabilities(data);
      } catch (err) {
        setError(err instanceof Error ? err : new Error('Unknown error occurred'));
      } finally {
        setIsLoading(false);
      }
    };
    
    fetchData();
  }, [fetchFromApi, initialData]);

  // Apply filters and sorting
  useEffect(() => {
    let result = [...vulnerabilities];
    
    // Apply search filter
    if (searchTerm) {
      result = result.filter(vuln => 
        vuln.name.toLowerCase().includes(searchTerm.toLowerCase()) || 
        vuln.type.toLowerCase().includes(searchTerm.toLowerCase()) ||
        vuln.affectedAssets.some(asset => asset.toLowerCase().includes(searchTerm.toLowerCase()))
      );
    }
    
    // Apply severity filter
    if (severityFilter !== 'All') {
      result = result.filter(vuln => vuln.severityLevel === severityFilter);
    }
    
    // Apply status filter
    if (statusFilter !== 'All') {
      result = result.filter(vuln => vuln.status === statusFilter);
    }
    
    // Apply date range filter
    if (startDate) {
      result = result.filter(vuln => new Date(vuln.discoveryDate) >= startDate);
    }
    
    if (endDate) {
      const endOfDay = new Date(endDate);
      endOfDay.setHours(23, 59, 59, 999);
      result = result.filter(vuln => new Date(vuln.discoveryDate) <= endOfDay);
    }
    
    // Apply sorting
    result.sort((a, b) => {
      if (sortField === 'cvssScore') {
        return sortDirection === 'asc' ? a.cvssScore - b.cvssScore : b.cvssScore - a.cvssScore;
      } else if (sortField === 'discoveryDate') {
        return sortDirection === 'asc' 
          ? new Date(a.discoveryDate).getTime() - new Date(b.discoveryDate).getTime()
          : new Date(b.discoveryDate).getTime() - new Date(a.discoveryDate).getTime();
      } else if (sortField === 'severityLevel') {
        const severityOrder: Record<string, number> = { 'Critical': 4, 'High': 3, 'Medium': 2, 'Low': 1 };
        return sortDirection === 'asc' 
          ? severityOrder[a.severityLevel] - severityOrder[b.severityLevel]
          : severityOrder[b.severityLevel] - severityOrder[a.severityLevel];
      }
      return 0;
    });
    
    setFilteredVulnerabilities(result);
  }, [vulnerabilities, searchTerm, severityFilter, statusFilter, startDate, endDate, sortField, sortDirection]);

  // Calculate summary statistics
  const summary = useMemo(() => {
    const criticalCount = vulnerabilities.filter(v => v.severityLevel === 'Critical').length;
    const highCount = vulnerabilities.filter(v => v.severityLevel === 'High').length;
    const mediumCount = vulnerabilities.filter(v => v.severityLevel === 'Medium').length;
    const lowCount = vulnerabilities.filter(v => v.severityLevel === 'Low').length;
    const fixedCount = vulnerabilities.filter(v => v.status === 'Fixed').length;
    const notFixedCount = vulnerabilities.filter(v => v.status === 'Not Fixed').length;
    const inProgressCount = vulnerabilities.filter(v => v.status === 'In Progress').length;

    // Find most affected asset
    const assetCounts = vulnerabilities.reduce((acc: Record<string, number>, vuln) => {
      vuln.affectedAssets.forEach(asset => {
        acc[asset] = (acc[asset] || 0) + 1;
      });
      return acc;
    }, {});

    const mostAffectedAsset = Object.entries(assetCounts).reduce(
      (max, [asset, count]) => count > max.count ? { name: asset, count } : max,
      { name: '', count: 0 }
    );

    return {
      total: vulnerabilities.length,
      critical: criticalCount,
      high: highCount,
      medium: mediumCount,
      low: lowCount,
      fixed: fixedCount,
      notFixed: notFixedCount,
      inProgress: inProgressCount,
      mostAffectedAsset
    };
  }, [vulnerabilities]);

  // Update vulnerability status
  const updateVulnerabilityStatus = (id: string, status: string) => {
    const updatedVulnerabilities = vulnerabilities.map(vuln => 
      vuln.id === id ? { ...vuln, status: status as 'Fixed' | 'Not Fixed' | 'In Progress' } : vuln
    );
    setVulnerabilities(updatedVulnerabilities);
  };

  // Reset filters
  const resetFilters = () => {
    setSearchTerm('');
    setSeverityFilter('All');
    setStatusFilter('All');
    setStartDate(null);
    setEndDate(null);
    setSortField('severityLevel');
    setSortDirection('desc');
  };

  return {
    vulnerabilities,
    filteredVulnerabilities,
    isLoading,
    error,
    summary,
    searchTerm,
    setSearchTerm,
    severityFilter,
    setSeverityFilter,
    statusFilter,
    setStatusFilter,
    startDate,
    setStartDate,
    endDate,
    setEndDate,
    sortField,
    setSortField,
    sortDirection,
    setSortDirection,
    updateVulnerabilityStatus,
    resetFilters
  };
}

export default useVulnerabilityData; 